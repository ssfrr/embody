#!/usr/bin/env python

'''

embody

Tools for embedded C development. Currently just generates fake implementations
from C header files. Configuration can be given as command line options or in a
.embodyrc.yaml file, or in .embody/config.yaml. These config files can be
placed in $HOME, or in the project directory. More specific config files (e.g.
per project) override more general ones (e.g. in $HOME). Command line arguments
take precedence.

Configuration files are a yaml dictionary. Keys are in the format of
'COMMAND_OPTION'. For example, to set the prefix for fake generation, you could
use `fake_prefix: "myprefix"`. Pro Tip: use the `-v` option to see where embody
has loaded the configuration.

Subcommands:
    fake
        Generate a fake header/implementation pair that implements the given
        header file

    project
        Generate an initial skeleton project

    module
        Generate a fake module within the current project

    showconfig
        Show the loaded configuration (use the -v flag to see where it's being
        loaded from)

Usage:
 embody fake [options] <header> [-- <cppargs>...]
 embody project [options] <name>
 embody module [options] <name>
 embody showconfig [options]
 embody test


Options:
 -d <outdir>, --outdir=<outdir>     Directory for generated header and source
 -t <testdir>, --testdir=<testdir>  Directory for generated test files
 -s <outsrc>, --outsrc=<outsrc>     Filename for generated source file
                                    (Overrides -d option)
 -h <outhead>, --outhead=<outhead>  Filename for generated header file
                                    (Overrides -d option)
 -p <prefix>, --prefix=<prefix>     Prefix for generated file (default: Fake)
 -v, --verbose                      Print extra info
 --help                             Print this helpful message
'''

import sys
from docopt import docopt
import embody
import coloredlogs
import logging
import pprint

logger = logging.getLogger()
logger.addHandler(coloredlogs.ColoredStreamHandler(
    show_name=False,
    show_severity=False,
    show_timestamps=False,
    show_hostname=False))
logger.setLevel(logging.INFO)


def dispatch_cmd(args):
    in_filename = args['<header>']
    out_dir = args['--outdir']
    out_src = args['--outsrc']
    out_header = args['--outhead']
    prefix = args['--prefix']
    cpp_args = args['<cppargs>']
    if len(cpp_args) > 0 and cpp_args[0] == '--':
        cpp_args = cpp_args[1:]
    # generate_fake distinguishes between an empty list of cpp_args, meaning
    # don't give any arguments, or None, which means pull the arguments from
    # the configuration. We don't have that flexibility from the command line,
    # so if the user doesn't supply any args we assume we want to load them.
    if len(cpp_args) == 0:
        cpp_args = None
    if args['fake']:
        embody.generate_fake(in_filename, out_dir, out_src, out_header,
                             prefix, cpp_args)
    elif args['test']:
        embody.test_templates()
    elif args['module']:
        logger.warning("Not Implemented")
    elif args['project']:
        logger.warning("Not Implemented")
    elif args['showconfig']:
        config = embody.get_config()
        pprint.pprint(config)


def main(args):
    if args['--verbose']:
        logger.setLevel(logging.DEBUG)
    logger.debug("Command line options: \n-----\n%s\n-----" % args)
    try:
        dispatch_cmd(args)
        return 0
    except embody.EmbodyError as e:
        logger.error(e)
        return -1


if __name__ == '__main__':
    args = docopt(__doc__)
    sys.exit(main(args))
